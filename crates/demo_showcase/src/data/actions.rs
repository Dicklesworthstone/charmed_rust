//! Domain action API for `demo_showcase`.
//!
//! This module provides a clean action API so multiple UI surfaces can trigger
//! the same behaviors without depending on each other. The API is designed to be:
//!
//! - **Pure-ish**: Given state + inputs, returns updated state + side effects
//! - **Testable**: Unit testable without a UI
//! - **Composable**: Actions can be batched or sequenced
//!
//! # Usage
//!
//! ```rust,ignore
//! use demo_showcase::data::actions::{Actions, ActionResult};
//!
//! let mut actions = Actions::new(initial_state);
//!
//! // Start a job
//! let result = actions.start_job(job_id);
//! if result.changed {
//!     // State was updated
//! }
//! // result.effects contains any Cmds to execute
//! // result.notifications contains UI notifications
//! ```

use bubbletea::{Cmd, Message};
use chrono::Utc;

use super::{
    Alert, AlertSeverity, Deployment, DeploymentStatus, Id, Job, JobKind, JobStatus, LogEntry,
    LogLevel,
};

// ============================================================================
// Notification Types
// ============================================================================

/// A user-facing notification (toast).
#[derive(Debug, Clone)]
pub struct Notification {
    /// Notification severity/style.
    pub severity: NotificationSeverity,
    /// Notification title.
    pub title: String,
    /// Optional detailed message.
    pub message: Option<String>,
    /// How long to show (None = sticky/until dismissed).
    pub duration_ms: Option<u64>,
}

/// Severity/style of a notification.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NotificationSeverity {
    /// Informational notice.
    Info,
    /// Success message.
    Success,
    /// Warning message.
    Warning,
    /// Error message.
    Error,
}

impl Notification {
    /// Create an info notification.
    #[must_use]
    pub fn info(title: impl Into<String>) -> Self {
        Self {
            severity: NotificationSeverity::Info,
            title: title.into(),
            message: None,
            duration_ms: Some(3000),
        }
    }

    /// Create a success notification.
    #[must_use]
    pub fn success(title: impl Into<String>) -> Self {
        Self {
            severity: NotificationSeverity::Success,
            title: title.into(),
            message: None,
            duration_ms: Some(3000),
        }
    }

    /// Create a warning notification.
    #[must_use]
    pub fn warning(title: impl Into<String>) -> Self {
        Self {
            severity: NotificationSeverity::Warning,
            title: title.into(),
            message: None,
            duration_ms: Some(5000),
        }
    }

    /// Create an error notification.
    #[must_use]
    pub fn error(title: impl Into<String>) -> Self {
        Self {
            severity: NotificationSeverity::Error,
            title: title.into(),
            message: None,
            duration_ms: None, // Errors are sticky
        }
    }

    /// Add a detailed message.
    #[must_use]
    pub fn with_message(mut self, message: impl Into<String>) -> Self {
        self.message = Some(message.into());
        self
    }

    /// Set custom duration.
    #[must_use]
    pub const fn with_duration(mut self, ms: u64) -> Self {
        self.duration_ms = Some(ms);
        self
    }

    /// Make the notification sticky (no auto-dismiss).
    #[must_use]
    pub const fn sticky(mut self) -> Self {
        self.duration_ms = None;
        self
    }
}

// ============================================================================
// Action Result
// ============================================================================

/// Result of an action, containing state changes and side effects.
#[derive(Default)]
pub struct ActionResult {
    /// Whether the action caused a state change.
    pub changed: bool,
    /// Commands to execute (async effects).
    pub effects: Vec<Cmd>,
    /// User-facing notifications to display.
    pub notifications: Vec<Notification>,
    /// Log entries generated by the action.
    pub log_entries: Vec<LogEntry>,
    /// Alerts generated by the action.
    pub alerts: Vec<Alert>,
}

impl ActionResult {
    /// Create an empty result (no changes).
    #[must_use]
    pub const fn empty() -> Self {
        Self {
            changed: false,
            effects: Vec::new(),
            notifications: Vec::new(),
            log_entries: Vec::new(),
            alerts: Vec::new(),
        }
    }

    /// Create a result indicating a state change occurred.
    #[must_use]
    pub const fn changed() -> Self {
        Self {
            changed: true,
            effects: Vec::new(),
            notifications: Vec::new(),
            log_entries: Vec::new(),
            alerts: Vec::new(),
        }
    }

    /// Add a notification.
    #[must_use]
    pub fn with_notification(mut self, notification: Notification) -> Self {
        self.notifications.push(notification);
        self
    }

    /// Add a log entry.
    #[must_use]
    pub fn with_log(mut self, entry: LogEntry) -> Self {
        self.log_entries.push(entry);
        self
    }

    /// Add an alert.
    #[must_use]
    pub fn with_alert(mut self, alert: Alert) -> Self {
        self.alerts.push(alert);
        self
    }

    /// Add an effect (command).
    #[must_use]
    pub fn with_effect(mut self, cmd: Cmd) -> Self {
        self.effects.push(cmd);
        self
    }

    /// Merge another result into this one.
    #[must_use]
    pub fn merge(mut self, other: Self) -> Self {
        self.changed = self.changed || other.changed;
        self.effects.extend(other.effects);
        self.notifications.extend(other.notifications);
        self.log_entries.extend(other.log_entries);
        self.alerts.extend(other.alerts);
        self
    }

    /// Convert effects to a batched command.
    #[must_use]
    pub fn into_cmd(self) -> Option<Cmd> {
        bubbletea::batch(self.effects.into_iter().map(Some).collect())
    }
}

// ============================================================================
// Action Messages
// ============================================================================

/// Messages generated by actions for UI updates.
#[derive(Debug, Clone)]
pub enum ActionMsg {
    /// A job was created.
    JobCreated(Id),
    /// A job was started.
    JobStarted(Id),
    /// A job was cancelled.
    JobCancelled(Id),
    /// A job was retried.
    JobRetried(Id),
    /// A job completed.
    JobCompleted(Id),
    /// A job failed.
    JobFailed(Id, String),
    /// A deployment was started.
    DeploymentStarted(Id),
    /// A deployment succeeded.
    DeploymentSucceeded(Id),
    /// A deployment failed.
    DeploymentFailed(Id),
    /// A deployment was rolled back.
    DeploymentRolledBack(Id),
    /// A notification should be shown.
    ShowNotification(Notification),
    /// A notification should be dismissed.
    DismissNotification,
}

impl ActionMsg {
    /// Convert to a bubbletea Message.
    #[must_use]
    pub fn into_message(self) -> Message {
        Message::new(self)
    }
}

// ============================================================================
// ID Generator
// ============================================================================

/// Simple ID generator for new entities.
#[derive(Debug, Clone, Default)]
pub struct IdGenerator {
    next_id: Id,
}

impl IdGenerator {
    /// Create a new ID generator starting at the given value.
    #[must_use]
    pub const fn new(start: Id) -> Self {
        Self { next_id: start }
    }

    /// Generate the next unique ID.
    pub const fn next(&mut self) -> Id {
        let id = self.next_id;
        self.next_id += 1;
        id
    }

    /// Get the current next ID without incrementing.
    #[must_use]
    pub const fn peek(&self) -> Id {
        self.next_id
    }

    /// Set the next ID (useful when syncing with existing data).
    pub const fn set_next(&mut self, id: Id) {
        self.next_id = id;
    }
}

// ============================================================================
// Job Actions
// ============================================================================

/// Create a new job and queue it.
///
/// Returns the created job and an action result.
#[must_use]
pub fn create_job(id_gen: &mut IdGenerator, name: &str, kind: JobKind) -> (Job, ActionResult) {
    let id = id_gen.next();
    let job = Job::new(id, name, kind);

    let result = ActionResult::changed()
        .with_notification(Notification::info(format!("Job '{name}' created")))
        .with_log(LogEntry::new(
            id_gen.next(),
            LogLevel::Info,
            "actions::job",
            format!("Created job '{name}' (id={id})"),
        ));

    (job, result)
}

/// Start a queued job.
///
/// Returns None if the job is not in Queued status.
pub fn start_job(job: &mut Job, id_gen: &mut IdGenerator) -> Option<ActionResult> {
    if job.status != JobStatus::Queued {
        return None;
    }

    job.status = JobStatus::Running;
    job.started_at = Some(Utc::now());
    job.progress = 0;

    Some(
        ActionResult::changed()
            .with_notification(Notification::info(format!("Job '{}' started", job.name)))
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Info,
                "actions::job",
                format!("Started job '{}' (id={})", job.name, job.id),
            )),
    )
}

/// Cancel a running or queued job.
///
/// Returns None if the job is already in a terminal state.
pub fn cancel_job(job: &mut Job, id_gen: &mut IdGenerator) -> Option<ActionResult> {
    if job.status.is_terminal() {
        return None;
    }

    let was_running = job.status == JobStatus::Running;
    job.status = JobStatus::Cancelled;
    job.ended_at = Some(Utc::now());

    let notification = if was_running {
        Notification::warning(format!("Job '{}' cancelled", job.name))
    } else {
        Notification::info(format!("Job '{}' cancelled", job.name))
    };

    Some(
        ActionResult::changed()
            .with_notification(notification)
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Warn,
                "actions::job",
                format!("Cancelled job '{}' (id={})", job.name, job.id),
            )),
    )
}

/// Retry a failed or cancelled job.
///
/// Returns None if the job is not in a retriable state.
pub fn retry_job(job: &mut Job, id_gen: &mut IdGenerator) -> Option<ActionResult> {
    if !matches!(job.status, JobStatus::Failed | JobStatus::Cancelled) {
        return None;
    }

    job.status = JobStatus::Queued;
    job.progress = 0;
    job.started_at = None;
    job.ended_at = None;
    job.error = None;

    Some(
        ActionResult::changed()
            .with_notification(Notification::info(format!(
                "Job '{}' queued for retry",
                job.name
            )))
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Info,
                "actions::job",
                format!("Retrying job '{}' (id={})", job.name, job.id),
            )),
    )
}

/// Mark a job as completed.
pub fn complete_job(job: &mut Job, id_gen: &mut IdGenerator) -> Option<ActionResult> {
    if job.status != JobStatus::Running {
        return None;
    }

    job.status = JobStatus::Completed;
    job.progress = 100;
    job.ended_at = Some(Utc::now());

    Some(
        ActionResult::changed()
            .with_notification(Notification::success(format!(
                "Job '{}' completed",
                job.name
            )))
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Info,
                "actions::job",
                format!("Completed job '{}' (id={})", job.name, job.id),
            )),
    )
}

/// Mark a job as failed.
pub fn fail_job(job: &mut Job, error: &str, id_gen: &mut IdGenerator) -> Option<ActionResult> {
    if job.status != JobStatus::Running {
        return None;
    }

    job.status = JobStatus::Failed;
    job.ended_at = Some(Utc::now());
    job.error = Some(error.to_string());

    Some(
        ActionResult::changed()
            .with_notification(
                Notification::error(format!("Job '{}' failed", job.name))
                    .with_message(error.to_string()),
            )
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Error,
                "actions::job",
                format!("Failed job '{}': {}", job.name, error),
            ))
            .with_alert(Alert::new(
                id_gen.next(),
                AlertSeverity::Error,
                format!("Job '{}' failed: {}", job.name, error),
                format!("job-failed-{}", job.id),
            )),
    )
}

// ============================================================================
// Deployment Actions
// ============================================================================

/// Create a new deployment.
#[must_use]
pub fn create_deployment(
    id_gen: &mut IdGenerator,
    service_id: Id,
    environment_id: Id,
    sha: &str,
    author: &str,
) -> (Deployment, ActionResult) {
    let id = id_gen.next();
    let deployment = Deployment::new(id, service_id, environment_id, sha, author);

    let result = ActionResult::changed()
        .with_notification(Notification::info(format!("Deployment {sha} queued")))
        .with_log(LogEntry::new(
            id_gen.next(),
            LogLevel::Info,
            "actions::deploy",
            format!("Created deployment (id={id}, sha={sha}, author={author})"),
        ));

    (deployment, result)
}

/// Start a pending deployment.
pub fn start_deployment(
    deployment: &mut Deployment,
    id_gen: &mut IdGenerator,
) -> Option<ActionResult> {
    if deployment.status != DeploymentStatus::Pending {
        return None;
    }

    deployment.status = DeploymentStatus::InProgress;
    deployment.started_at = Some(Utc::now());

    Some(
        ActionResult::changed()
            .with_notification(Notification::info(format!(
                "Deployment {} started",
                deployment.sha
            )))
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Info,
                "actions::deploy",
                format!(
                    "Started deployment (id={}, sha={})",
                    deployment.id, deployment.sha
                ),
            )),
    )
}

/// Mark a deployment as succeeded.
pub fn succeed_deployment(
    deployment: &mut Deployment,
    id_gen: &mut IdGenerator,
) -> Option<ActionResult> {
    if deployment.status != DeploymentStatus::InProgress {
        return None;
    }

    deployment.status = DeploymentStatus::Succeeded;
    deployment.ended_at = Some(Utc::now());

    Some(
        ActionResult::changed()
            .with_notification(Notification::success(format!(
                "Deployment {} succeeded",
                deployment.sha
            )))
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Info,
                "actions::deploy",
                format!(
                    "Deployment succeeded (id={}, sha={})",
                    deployment.id, deployment.sha
                ),
            )),
    )
}

/// Mark a deployment as failed.
pub fn fail_deployment(
    deployment: &mut Deployment,
    id_gen: &mut IdGenerator,
) -> Option<ActionResult> {
    if deployment.status != DeploymentStatus::InProgress {
        return None;
    }

    deployment.status = DeploymentStatus::Failed;
    deployment.ended_at = Some(Utc::now());

    Some(
        ActionResult::changed()
            .with_notification(Notification::error(format!(
                "Deployment {} failed",
                deployment.sha
            )))
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Error,
                "actions::deploy",
                format!(
                    "Deployment failed (id={}, sha={})",
                    deployment.id, deployment.sha
                ),
            ))
            .with_alert(Alert::new(
                id_gen.next(),
                AlertSeverity::Error,
                format!("Deployment {} failed", deployment.sha),
                format!("deploy-failed-{}", deployment.id),
            )),
    )
}

/// Rollback a deployment.
pub fn rollback_deployment(
    deployment: &mut Deployment,
    id_gen: &mut IdGenerator,
) -> Option<ActionResult> {
    if !matches!(
        deployment.status,
        DeploymentStatus::InProgress | DeploymentStatus::Succeeded | DeploymentStatus::Failed
    ) {
        return None;
    }

    let was_in_progress = deployment.status == DeploymentStatus::InProgress;
    deployment.status = DeploymentStatus::RolledBack;
    deployment.ended_at = Some(Utc::now());

    let notification = if was_in_progress {
        Notification::warning(format!("Deployment {} rolled back", deployment.sha))
    } else {
        Notification::info(format!("Deployment {} rolled back", deployment.sha))
    };

    Some(
        ActionResult::changed()
            .with_notification(notification)
            .with_log(LogEntry::new(
                id_gen.next(),
                LogLevel::Warn,
                "actions::deploy",
                format!(
                    "Deployment rolled back (id={}, sha={})",
                    deployment.id, deployment.sha
                ),
            )),
    )
}

// ============================================================================
// Logging Actions
// ============================================================================

/// Create a log entry.
#[must_use]
pub fn log(
    id_gen: &mut IdGenerator,
    level: LogLevel,
    target: &str,
    message: &str,
) -> (LogEntry, ActionResult) {
    let id = id_gen.next();
    let entry = LogEntry::new(id, level, target, message);

    (entry, ActionResult::changed())
}

/// Create a log entry with fields.
#[must_use]
pub fn log_with_fields(
    id_gen: &mut IdGenerator,
    level: LogLevel,
    target: &str,
    message: &str,
    fields: impl IntoIterator<Item = (impl Into<String>, impl Into<String>)>,
) -> (LogEntry, ActionResult) {
    let id = id_gen.next();
    let mut entry = LogEntry::new(id, level, target, message);

    for (key, value) in fields {
        entry.fields.insert(key.into(), value.into());
    }

    (entry, ActionResult::changed())
}

// ============================================================================
// Alert Actions
// ============================================================================

/// Create an alert.
#[must_use]
pub fn create_alert(
    id_gen: &mut IdGenerator,
    severity: AlertSeverity,
    message: &str,
    dedupe_key: &str,
) -> (Alert, ActionResult) {
    let id = id_gen.next();
    let alert = Alert::new(id, severity, message, dedupe_key);

    let notification = match severity {
        AlertSeverity::Info => Notification::info(message),
        AlertSeverity::Warning => Notification::warning(message),
        AlertSeverity::Error | AlertSeverity::Critical => Notification::error(message),
    };

    (
        alert,
        ActionResult::changed().with_notification(notification),
    )
}

/// Acknowledge an alert.
pub fn acknowledge_alert(alert: &mut Alert, id_gen: &mut IdGenerator) -> Option<ActionResult> {
    if alert.acknowledged {
        return None;
    }

    alert.acknowledged = true;

    Some(ActionResult::changed().with_log(LogEntry::new(
        id_gen.next(),
        LogLevel::Info,
        "actions::alert",
        format!("Acknowledged alert: {}", alert.message),
    )))
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn notification_builders() {
        let info = Notification::info("Hello");
        assert_eq!(info.severity, NotificationSeverity::Info);
        assert_eq!(info.duration_ms, Some(3000));

        let success = Notification::success("Done").with_duration(5000);
        assert_eq!(success.severity, NotificationSeverity::Success);
        assert_eq!(success.duration_ms, Some(5000));

        let error = Notification::error("Failed").sticky();
        assert_eq!(error.severity, NotificationSeverity::Error);
        assert!(error.duration_ms.is_none());
    }

    #[test]
    fn action_result_merge() {
        let r1 = ActionResult::changed().with_notification(Notification::info("A"));
        let r2 = ActionResult::empty().with_notification(Notification::info("B"));

        let merged = r1.merge(r2);
        assert!(merged.changed);
        assert_eq!(merged.notifications.len(), 2);
    }

    #[test]
    fn id_generator() {
        let mut id_gen = IdGenerator::new(100);
        assert_eq!(id_gen.next(), 100);
        assert_eq!(id_gen.next(), 101);
        assert_eq!(id_gen.peek(), 102);

        id_gen.set_next(500);
        assert_eq!(id_gen.next(), 500);
    }

    #[test]
    fn create_job_works() {
        let mut id_gen = IdGenerator::new(1);
        let (job, result) = create_job(&mut id_gen, "Test Job", JobKind::Build);

        assert_eq!(job.id, 1);
        assert_eq!(job.status, JobStatus::Queued);
        assert!(result.changed);
        assert_eq!(result.notifications.len(), 1);
        assert_eq!(result.log_entries.len(), 1);
    }

    #[test]
    fn start_job_only_from_queued() {
        let mut id_gen = IdGenerator::new(1);
        let (mut job, _) = create_job(&mut id_gen, "Test", JobKind::Task);

        // Can start from Queued
        assert!(start_job(&mut job, &mut id_gen).is_some());
        assert_eq!(job.status, JobStatus::Running);

        // Cannot start again
        assert!(start_job(&mut job, &mut id_gen).is_none());
    }

    #[test]
    fn cancel_job_works() {
        let mut id_gen = IdGenerator::new(1);
        let (mut job, _) = create_job(&mut id_gen, "Test", JobKind::Task);

        // Cancel from queued
        let result = cancel_job(&mut job, &mut id_gen);
        assert!(result.is_some());
        assert_eq!(job.status, JobStatus::Cancelled);

        // Cannot cancel again
        assert!(cancel_job(&mut job, &mut id_gen).is_none());
    }

    #[test]
    fn retry_job_only_from_failed_or_cancelled() {
        let mut id_gen = IdGenerator::new(1);
        let (mut job, _) = create_job(&mut id_gen, "Test", JobKind::Task);

        // Cannot retry from Queued
        assert!(retry_job(&mut job, &mut id_gen).is_none());

        // Start and fail
        start_job(&mut job, &mut id_gen);
        fail_job(&mut job, "error", &mut id_gen);

        // Can retry from Failed
        let result = retry_job(&mut job, &mut id_gen);
        assert!(result.is_some());
        assert_eq!(job.status, JobStatus::Queued);
    }

    #[test]
    fn complete_job_only_from_running() {
        let mut id_gen = IdGenerator::new(1);
        let (mut job, _) = create_job(&mut id_gen, "Test", JobKind::Task);

        // Cannot complete from Queued
        assert!(complete_job(&mut job, &mut id_gen).is_none());

        start_job(&mut job, &mut id_gen);
        let result = complete_job(&mut job, &mut id_gen);
        assert!(result.is_some());
        assert_eq!(job.status, JobStatus::Completed);
        assert_eq!(job.progress, 100);
    }

    #[test]
    fn fail_job_creates_alert() {
        let mut id_gen = IdGenerator::new(1);
        let (mut job, _) = create_job(&mut id_gen, "Test", JobKind::Task);
        start_job(&mut job, &mut id_gen);

        let result = fail_job(&mut job, "Something went wrong", &mut id_gen).unwrap();
        assert!(result.changed);
        assert_eq!(result.alerts.len(), 1);
        assert_eq!(result.alerts[0].severity, AlertSeverity::Error);
    }

    #[test]
    fn deployment_lifecycle() {
        let mut id_gen = IdGenerator::new(1);

        let (mut deploy, _) = create_deployment(&mut id_gen, 100, 200, "abc123", "user");
        assert_eq!(deploy.status, DeploymentStatus::Pending);

        start_deployment(&mut deploy, &mut id_gen);
        assert_eq!(deploy.status, DeploymentStatus::InProgress);

        succeed_deployment(&mut deploy, &mut id_gen);
        assert_eq!(deploy.status, DeploymentStatus::Succeeded);
    }

    #[test]
    fn rollback_deployment_works() {
        let mut id_gen = IdGenerator::new(1);

        let (mut deploy, _) = create_deployment(&mut id_gen, 100, 200, "abc123", "user");
        start_deployment(&mut deploy, &mut id_gen);

        let result = rollback_deployment(&mut deploy, &mut id_gen);
        assert!(result.is_some());
        assert_eq!(deploy.status, DeploymentStatus::RolledBack);
    }

    #[test]
    fn log_with_fields_works() {
        let mut id_gen = IdGenerator::new(1);

        let (entry, result) = log_with_fields(
            &mut id_gen,
            LogLevel::Info,
            "test",
            "Hello",
            [("user_id", "123"), ("action", "login")],
        );

        assert_eq!(entry.fields.len(), 2);
        assert!(result.changed);
    }

    #[test]
    fn acknowledge_alert_works() {
        let mut id_gen = IdGenerator::new(1);
        let (mut alert, _) = create_alert(&mut id_gen, AlertSeverity::Warning, "Test", "key");

        let result = acknowledge_alert(&mut alert, &mut id_gen);
        assert!(result.is_some());
        assert!(alert.acknowledged);

        // Cannot acknowledge again
        assert!(acknowledge_alert(&mut alert, &mut id_gen).is_none());
    }
}
