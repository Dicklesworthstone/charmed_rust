//! Core derive logic for the Model trait.
//!
//! This module contains the implementation of the `#[derive(Model)]` macro.
//!
//! # Design
//!
//! The derive macro generates a `bubbletea::Model` trait implementation that
//! delegates to inherent methods on the struct. Users implement `init`, `update`,
//! and `view` as inherent methods, and the macro bridges them to the trait.
//!
//! # Example
//!
//! ```rust,ignore
//! use bubbletea::{Cmd, Message, Model};
//!
//! #[derive(Model)]
//! struct Counter {
//!     count: i32,
//! }
//!
//! impl Counter {
//!     fn init(&self) -> Option<Cmd> {
//!         None
//!     }
//!
//!     fn update(&mut self, msg: Message) -> Option<Cmd> {
//!         if let Some(&delta) = msg.downcast_ref::<i32>() {
//!             self.count += delta;
//!         }
//!         None
//!     }
//!
//!     fn view(&self) -> String {
//!         format!("Count: {}", self.count)
//!     }
//! }
//! ```

use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{DeriveInput, parse2};

use crate::attributes::ModelInput;
use crate::error::MacroError;
use crate::state::{StateField, generate_state_snapshot_with_generics};

/// Main implementation for the derive macro.
///
/// This function is called by the proc_macro entry point and handles
/// parsing the input and generating the output token stream.
pub fn derive_model_impl(input: TokenStream) -> TokenStream {
    match derive_model_inner(input) {
        Ok(tokens) => tokens,
        Err(err) => err.to_compile_error(),
    }
}

/// Inner implementation that can return errors.
///
/// This separation allows for cleaner error handling using the `?` operator.
fn derive_model_inner(input: TokenStream) -> Result<TokenStream, MacroError> {
    let input: DeriveInput = parse2(input)?;
    let name = &input.ident;
    let generics = &input.generics;

    // Validate that we're deriving on a named struct, not an enum, union, or tuple struct
    match &input.data {
        syn::Data::Struct(data) => {
            // Reject tuple structs and unit structs
            match &data.fields {
                syn::Fields::Named(_) => {} // OK
                syn::Fields::Unnamed(_) => {
                    return Err(MacroError::unsupported_item(
                        "a named struct with fields",
                        "tuple struct",
                        name.span(),
                    ));
                }
                syn::Fields::Unit => {
                    return Err(MacroError::unsupported_item(
                        "a named struct with fields",
                        "unit struct",
                        name.span(),
                    ));
                }
            }
        }
        syn::Data::Enum(_) => {
            return Err(MacroError::unsupported_item(
                "a struct",
                "enum",
                name.span(),
            ));
        }
        syn::Data::Union(_) => {
            return Err(MacroError::unsupported_item(
                "a struct",
                "union",
                name.span(),
            ));
        }
    }

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    #[cfg(debug_assertions)]
    eprintln!("[bubbletea-macros] Deriving Model for: {}", name);

    // Parse fields using darling for #[state] attribute handling
    let parsed = ModelInput::from_derive_input(&input)?;

    // Extract state-tracked fields
    let state_fields: Vec<StateField<'_>> = parsed
        .fields()
        .iter()
        .filter_map(|f| StateField::from_model_field(f))
        .collect();

    // Generate state snapshot code for change detection
    let state_snapshot = generate_state_snapshot_with_generics(name, &state_fields, generics);

    // Generate the Model trait implementation.
    //
    // The implementation delegates to inherent methods on the struct:
    // - init(&self) -> Option<Cmd>
    // - update(&mut self, msg: Message) -> Option<Cmd>
    // - view(&self) -> String
    //
    // We use fully-qualified syntax `Self::method(self, ...)` to call
    // the inherent methods rather than the trait methods.

    let expanded = quote! {
        impl #impl_generics ::bubbletea::Model for #name #ty_generics #where_clause {
            fn init(&self) -> ::std::option::Option<::bubbletea::Cmd> {
                #name::init(self)
            }

            fn update(&mut self, msg: ::bubbletea::Message) -> ::std::option::Option<::bubbletea::Cmd> {
                #name::update(self, msg)
            }

            fn view(&self) -> ::std::string::String {
                #name::view(self)
            }
        }

        impl #impl_generics #name #ty_generics #where_clause {
            /// Returns the type name (generated by derive macro).
            #[doc(hidden)]
            pub fn __bubbletea_type_name() -> &'static str {
                stringify!(#name)
            }
        }

        #state_snapshot
    };

    Ok(expanded)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_derive() {
        let input = quote! {
            struct Counter {
                count: i32,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model trait implementation
        assert!(output_str.contains("impl :: bubbletea :: Model for Counter"));
        assert!(output_str.contains("fn init"));
        assert!(output_str.contains("fn update"));
        assert!(output_str.contains("fn view"));
        assert!(output_str.contains("Counter :: init"));
        assert!(output_str.contains("Counter :: update"));
        assert!(output_str.contains("Counter :: view"));
        assert!(output_str.contains("__bubbletea_type_name"));
    }

    #[test]
    fn test_struct_with_generics() {
        let input = quote! {
            struct App<T> {
                data: T,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle generics
        assert!(output_str.contains("impl < T > :: bubbletea :: Model for App < T >"));
        assert!(output_str.contains("App :: init"));
    }

    #[test]
    fn test_struct_with_lifetime() {
        let input = quote! {
            struct AppWithLifetime<'a> {
                name: &'a str,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle lifetimes
        assert!(
            output_str.contains("impl < 'a > :: bubbletea :: Model for AppWithLifetime < 'a >")
        );
    }

    #[test]
    fn test_struct_with_where_clause() {
        let input = quote! {
            struct GenericApp<T>
            where
                T: Clone,
            {
                value: T,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should preserve where clause
        assert!(output_str.contains("where T : Clone"));
    }

    #[test]
    fn test_struct_with_state_attribute() {
        let input = quote! {
            struct MyApp {
                #[state]
                text: String,
                #[state]
                count: i32,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model impl
        assert!(output_str.contains("impl :: bubbletea :: Model for MyApp"));

        // Should generate state snapshot struct
        assert!(output_str.contains("__MyAppStateSnapshot"));
        assert!(output_str.contains("text : String"));
        assert!(output_str.contains("count : i32"));

        // Should generate snapshot method
        assert!(output_str.contains("__snapshot_state"));

        // Should generate state changed method
        assert!(output_str.contains("__state_changed"));
    }

    #[test]
    fn test_struct_with_state_options() {
        let input = quote! {
            struct App {
                #[state(eq = "custom_eq")]
                progress: f64,
                #[state(skip)]
                timestamp: u64,
                #[state(debug)]
                selected: usize,
                cache: String,  // not tracked
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should include progress and selected in snapshot (not timestamp or cache)
        assert!(output_str.contains("progress : f64"));
        assert!(output_str.contains("selected : usize"));
        assert!(!output_str.contains("timestamp : u64")); // skipped
        assert!(!output_str.contains("cache : String")); // not #[state]

        // Should use custom equality for progress
        assert!(output_str.contains("custom_eq"));

        // Should have debug logging for selected
        assert!(output_str.contains("eprintln !"));
    }

    #[test]
    fn test_combined_eq_and_debug() {
        let input = quote! {
            struct CombinedApp {
                #[state(eq = "float_eq", debug)]
                progress: f64,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should use custom equality with debug logging
        assert!(output_str.contains("float_eq"), "Should contain custom eq function");
        assert!(output_str.contains("eprintln !"), "Should contain debug logging");

        // The change detection should be properly structured
        assert!(output_str.contains("__changed"), "Should use __changed variable");
    }

    #[test]
    fn test_multiple_combined_eq_and_debug() {
        let input = quote! {
            struct MultiApp {
                #[state(eq = "float_eq", debug)]
                progress: f64,
                #[state(eq = "str_eq", debug)]
                name: String,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Print for debugging
        eprintln!("Generated code for multiple combined eq+debug:\n{}", output_str);

        // Should use both custom equality functions
        assert!(output_str.contains("float_eq"), "Should contain float_eq function");
        assert!(output_str.contains("str_eq"), "Should contain str_eq function");

        // The state_changed method should use || to combine checks
        assert!(output_str.contains("||"), "Should combine checks with OR");
    }

    #[test]
    fn test_struct_without_state_fields() {
        let input = quote! {
            struct SimpleApp {
                data: String,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model impl
        assert!(output_str.contains("impl :: bubbletea :: Model for SimpleApp"));

        // Should have stub methods that return false/unit
        assert!(output_str.contains("__state_changed"));
        assert!(output_str.contains("__snapshot_state"));
        assert!(output_str.contains("false")); // always returns false
    }

    #[test]
    fn test_empty_struct() {
        let input = quote! {
            struct EmptyApp {}
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model impl even for empty structs
        assert!(output_str.contains("impl :: bubbletea :: Model for EmptyApp"));
        assert!(output_str.contains("fn init"));
        assert!(output_str.contains("fn update"));
        assert!(output_str.contains("fn view"));
    }

    #[test]
    fn test_many_fields() {
        let input = quote! {
            struct LargeApp {
                #[state]
                a: i32,
                #[state]
                b: i32,
                #[state]
                c: String,
                d: i32,
                e: i32,
                f: String,
                g: bool,
                h: u64,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model impl
        assert!(output_str.contains("impl :: bubbletea :: Model for LargeApp"));

        // Should track only state fields
        assert!(output_str.contains("a : i32"));
        assert!(output_str.contains("b : i32"));
        assert!(output_str.contains("c : String"));

        // Non-state fields should not be in snapshot
        assert!(!output_str.contains("d : i32"));
        assert!(!output_str.contains("e : i32"));
    }

    #[test]
    fn test_complex_field_types() {
        let input = quote! {
            struct ComplexApp {
                #[state]
                items: Vec<String>,
                #[state]
                mapping: std::collections::HashMap<String, i32>,
                optional: Option<Box<String>>,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle complex types
        assert!(output_str.contains("impl :: bubbletea :: Model for ComplexApp"));
        assert!(output_str.contains("items : Vec < String >"));
        assert!(output_str.contains("mapping : std :: collections :: HashMap < String , i32 >"));
    }

    #[test]
    fn test_generic_with_state_fields() {
        let input = quote! {
            struct GenericState<T>
            where
                T: Clone + PartialEq,
            {
                #[state]
                value: T,
                metadata: String,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle generics with state
        assert!(output_str.contains("impl < T > :: bubbletea :: Model for GenericState < T >"));
        assert!(output_str.contains("where T : Clone + PartialEq"));

        // Snapshot struct should also be generic
        assert!(output_str.contains("__GenericStateStateSnapshot"));
        assert!(output_str.contains("value : T"));
    }

    #[test]
    fn test_lifetime_with_state() {
        let input = quote! {
            struct RefApp<'a> {
                #[state]
                data: &'a str,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle lifetimes with state
        assert!(output_str.contains("impl < 'a > :: bubbletea :: Model for RefApp < 'a >"));
        assert!(output_str.contains("__RefAppStateSnapshot"));
    }

    #[test]
    fn test_multiple_generics_and_lifetimes() {
        let input = quote! {
            struct MultiGeneric<'a, T, U>
            where
                T: Clone,
                U: Default,
            {
                #[state]
                first: T,
                second: U,
                reference: &'a str,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle multiple generics and lifetimes
        assert!(output_str
            .contains("impl < 'a , T , U > :: bubbletea :: Model for MultiGeneric < 'a , T , U >"));
    }

    #[test]
    fn test_state_debug_generates_logging() {
        let input = quote! {
            struct DebugApp {
                #[state(debug)]
                value: i32,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate debug logging
        assert!(output_str.contains("eprintln !"));
        assert!(output_str.contains("value"));
    }

    #[test]
    fn test_all_fields_skipped() {
        let input = quote! {
            struct AllSkipped {
                #[state(skip)]
                internal1: u64,
                #[state(skip)]
                internal2: String,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model impl
        assert!(output_str.contains("impl :: bubbletea :: Model for AllSkipped"));

        // With all fields skipped, state_changed should always return false
        assert!(output_str.contains("__state_changed"));
        assert!(output_str.contains("false"));
    }
}
