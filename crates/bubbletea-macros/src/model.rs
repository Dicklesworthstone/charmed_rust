//! Core derive logic for the Model trait.
//!
//! This module contains the implementation of the `#[derive(Model)]` macro.

use proc_macro2::TokenStream;
use quote::quote;
use syn::{parse2, DeriveInput};

use crate::error::MacroError;

/// Main implementation for the derive macro.
///
/// This function is called by the proc_macro entry point and handles
/// parsing the input and generating the output token stream.
pub fn derive_model_impl(input: TokenStream) -> TokenStream {
    match derive_model_inner(input) {
        Ok(tokens) => tokens,
        Err(err) => err.to_compile_error(),
    }
}

/// Inner implementation that can return errors.
///
/// This separation allows for cleaner error handling using the `?` operator.
fn derive_model_inner(input: TokenStream) -> Result<TokenStream, MacroError> {
    let input: DeriveInput = parse2(input)?;
    let name = &input.ident;

    #[cfg(debug_assertions)]
    eprintln!("[bubbletea-macros] Parsing struct: {}", name);

    // For now, generate a placeholder implementation.
    // The actual Model trait implementation will be added in charmed_rust-7k2.
    //
    // This skeleton allows the crate to compile and be used as a dependency,
    // while the real functionality is being developed.

    let expanded = quote! {
        // Placeholder: Full Model implementation will be generated here.
        // See charmed_rust-7k2 for the actual implementation.
        impl #name {
            /// Returns the type name (generated by derive macro).
            #[doc(hidden)]
            pub fn __bubbletea_type_name() -> &'static str {
                stringify!(#name)
            }
        }
    };

    Ok(expanded)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_derive() {
        let input = quote! {
            struct Counter {
                count: i32,
            }
        };

        let output = derive_model_impl(input);

        // Should not produce an error
        let output_str = output.to_string();
        assert!(output_str.contains("__bubbletea_type_name"));
        assert!(output_str.contains("Counter"));
    }

    #[test]
    fn test_struct_with_attributes() {
        let input = quote! {
            struct MyApp {
                #[state]
                text: String,
                #[state]
                count: i32,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();
        assert!(output_str.contains("MyApp"));
    }
}
