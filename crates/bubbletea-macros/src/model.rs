//! Core derive logic for the Model trait.
//!
//! This module contains the implementation of the `#[derive(Model)]` macro.
//!
//! # Design
//!
//! The derive macro generates a `bubbletea::Model` trait implementation that
//! delegates to inherent methods on the struct. Users implement `init`, `update`,
//! and `view` as inherent methods, and the macro bridges them to the trait.
//!
//! # Example
//!
//! ```rust,ignore
//! use bubbletea::{Cmd, Message, Model};
//!
//! #[derive(Model)]
//! struct Counter {
//!     count: i32,
//! }
//!
//! impl Counter {
//!     fn init(&self) -> Option<Cmd> {
//!         None
//!     }
//!
//!     fn update(&mut self, msg: Message) -> Option<Cmd> {
//!         if let Some(&delta) = msg.downcast_ref::<i32>() {
//!             self.count += delta;
//!         }
//!         None
//!     }
//!
//!     fn view(&self) -> String {
//!         format!("Count: {}", self.count)
//!     }
//! }
//! ```

use proc_macro2::TokenStream;
use quote::quote;
use syn::{DeriveInput, parse2};

use crate::error::MacroError;

/// Main implementation for the derive macro.
///
/// This function is called by the proc_macro entry point and handles
/// parsing the input and generating the output token stream.
pub fn derive_model_impl(input: TokenStream) -> TokenStream {
    match derive_model_inner(input) {
        Ok(tokens) => tokens,
        Err(err) => err.to_compile_error(),
    }
}

/// Inner implementation that can return errors.
///
/// This separation allows for cleaner error handling using the `?` operator.
fn derive_model_inner(input: TokenStream) -> Result<TokenStream, MacroError> {
    let input: DeriveInput = parse2(input)?;
    let name = &input.ident;
    let generics = &input.generics;

    // Validate that we're deriving on a named struct, not an enum, union, or tuple struct
    match &input.data {
        syn::Data::Struct(data) => {
            // Reject tuple structs and unit structs
            match &data.fields {
                syn::Fields::Named(_) => {} // OK
                syn::Fields::Unnamed(_) => {
                    return Err(MacroError::unsupported_item(
                        "a named struct with fields",
                        "tuple struct",
                        name.span(),
                    ));
                }
                syn::Fields::Unit => {
                    return Err(MacroError::unsupported_item(
                        "a named struct with fields",
                        "unit struct",
                        name.span(),
                    ));
                }
            }
        }
        syn::Data::Enum(_) => {
            return Err(MacroError::unsupported_item(
                "a struct",
                "enum",
                name.span(),
            ));
        }
        syn::Data::Union(_) => {
            return Err(MacroError::unsupported_item(
                "a struct",
                "union",
                name.span(),
            ));
        }
    }

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    #[cfg(debug_assertions)]
    eprintln!("[bubbletea-macros] Deriving Model for: {}", name);

    // Generate the Model trait implementation.
    //
    // The implementation delegates to inherent methods on the struct:
    // - init(&self) -> Option<Cmd>
    // - update(&mut self, msg: Message) -> Option<Cmd>
    // - view(&self) -> String
    //
    // We use fully-qualified syntax `Self::method(self, ...)` to call
    // the inherent methods rather than the trait methods.

    let expanded = quote! {
        impl #impl_generics ::bubbletea::Model for #name #ty_generics #where_clause {
            fn init(&self) -> ::std::option::Option<::bubbletea::Cmd> {
                #name::init(self)
            }

            fn update(&mut self, msg: ::bubbletea::Message) -> ::std::option::Option<::bubbletea::Cmd> {
                #name::update(self, msg)
            }

            fn view(&self) -> ::std::string::String {
                #name::view(self)
            }
        }

        impl #impl_generics #name #ty_generics #where_clause {
            /// Returns the type name (generated by derive macro).
            #[doc(hidden)]
            pub fn __bubbletea_type_name() -> &'static str {
                stringify!(#name)
            }
        }
    };

    Ok(expanded)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_derive() {
        let input = quote! {
            struct Counter {
                count: i32,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should generate Model trait implementation
        assert!(output_str.contains("impl :: bubbletea :: Model for Counter"));
        assert!(output_str.contains("fn init"));
        assert!(output_str.contains("fn update"));
        assert!(output_str.contains("fn view"));
        assert!(output_str.contains("Counter :: init"));
        assert!(output_str.contains("Counter :: update"));
        assert!(output_str.contains("Counter :: view"));
        assert!(output_str.contains("__bubbletea_type_name"));
    }

    #[test]
    fn test_struct_with_generics() {
        let input = quote! {
            struct App<T> {
                data: T,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle generics
        assert!(output_str.contains("impl < T > :: bubbletea :: Model for App < T >"));
        assert!(output_str.contains("App :: init"));
    }

    #[test]
    fn test_struct_with_lifetime() {
        let input = quote! {
            struct AppWithLifetime<'a> {
                name: &'a str,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should handle lifetimes
        assert!(
            output_str.contains("impl < 'a > :: bubbletea :: Model for AppWithLifetime < 'a >")
        );
    }

    #[test]
    fn test_struct_with_where_clause() {
        let input = quote! {
            struct GenericApp<T>
            where
                T: Clone,
            {
                value: T,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should preserve where clause
        assert!(output_str.contains("where T : Clone"));
    }

    #[test]
    fn test_struct_with_state_attribute() {
        let input = quote! {
            struct MyApp {
                #[state]
                text: String,
                #[state]
                count: i32,
            }
        };

        let output = derive_model_impl(input);
        let output_str = output.to_string();

        // Should still generate Model impl (state attribute for future use)
        assert!(output_str.contains("impl :: bubbletea :: Model for MyApp"));
    }
}
